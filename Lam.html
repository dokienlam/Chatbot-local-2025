<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ChatBot</title>
    <link rel="stylesheet" href="/style.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>

<body>
    <section class="msger">
        <header class="msger-header">
            <div class="msger-header-title">
                <i class="fas fa-bug"></i> ChatBot <i class="fas fa-bug"></i>
            </div>
            <div class="recording-timer" id="timer">00:00</div> <!-- Timer display -->
        </header>
        <main class="msger-chat">
            <div class="msg left-msg">
                <div class="msg-img" style="background-image: url(https://image.flaticon.com/icons/svg/327/327779.svg)">
                </div>
                <div class="msg-bubble">
                    <div class="msg-info">
                        <div class="msg-info-name">ChatBot</div>
                        <div class="msg-info-time"></div>
                    </div>
                    <div class="msg-text">
                        Hi, welcome to ChatBot! üòÑ
                    </div>
                </div>
            </div>
        </main>
        <form class="msger-inputarea">
            <input type="text" class="msger-input" id="textInput" placeholder="Enter your message...">
            <button type="submit" class="msger-send-btn">Send</button>
            <button type="button" id="startInteract" class="msger-interact-btn">Start Interact</button>
        </form>
    </section>

    <!-- FontAwesome Icons -->
    <script src='https://use.fontawesome.com/releases/v5.0.13/js/all.js'></script>

    <script>


        const msgerForm = get(".msger-inputarea");
        const msgerInput = get(".msger-input");
        const msgerChat = get(".msger-chat");
        const startInteractBtn = get("#startInteract");
    
        let mediaRecorder;
        let audioChunks = [];
        let recordingTimer;
        let timerInterval;
        let isRecording = false;
    
        // Khi b·∫•m "Start Interact" th√¨ b·∫Øt ƒë·∫ßu ghi √¢m v√† sau ƒë√≥ bot s·∫Ω ph·∫£n h·ªìi b·∫±ng speech
        // ... (existing code remains unchanged)

// When "Start Interact" button is clicked, start recording audio
startInteractBtn.addEventListener("click", () => {
    if (isRecording) {
        mediaRecorder.stop();
        stopTimer();
        isRecording = false;
        startInteractBtn.textContent = "Start Interact";
    } else {
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.start();
            audioChunks = [];

            mediaRecorder.addEventListener("dataavailable", event => {
                audioChunks.push(event.data);
            });

            mediaRecorder.addEventListener("stop", () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                
                // Send the audio blob to the server
                uploadAudio(audioBlob);

                // After the user stops recording, respond with speech
                const userMsg = "interact"; // Adjust logic if necessary
                const response = botResponses[userMsg] || "Sorry, I don't understand your request.";
                appendMessage("ChatBot", BOT_IMG, "left", response);

                // Convert text from JSON to speech
                textToSpeech(response);
            });

            startTimer();
            isRecording = true;
            startInteractBtn.textContent = "Stop Interact";

            setTimeout(() => {
                if (isRecording) {
                    mediaRecorder.stop();
                    stopTimer();
                }
            }, 60000);  // 1 minute
        }).catch(error => {
            console.error("Error accessing microphone:", error);
        });
    }
});

// Function to upload audio blob to the server
function uploadAudio(blob) {
    const formData = new FormData();
    formData.append('audio', blob, `user_recording_${Date.now()}.wav`);

    fetch('/upload', {
        method: 'POST',
        body: formData,
    })
    .then(response => response.json())
    .then(data => {
        console.log('Server response:', data);
        appendMessage("ChatBot", BOT_IMG, "left", `Audio file saved: ${data.file}`);
    })
    .catch(error => console.error('Error uploading audio:', error));
}

// G·ª≠i tin nh·∫Øn m√† kh√¥ng k√≠ch ho·∫°t ghi √¢m
msgerForm.addEventListener("submit", event => {
    event.preventDefault();
    const msgText = msgerInput.value.trim().toLowerCase();
    if (!msgText) return;

    appendMessage("You", PERSON_IMG, "right", msgText);
    msgerInput.value = "";

    // T·∫£i JSON v√† in ra t·∫•t c·∫£ gi√° tr·ªã
    fetch('./responses.json')
        .then(response => response.json())
        .then(data => {
            // Duy·ªát qua t·∫•t c·∫£ c√°c gi√° tr·ªã trong ƒë·ªëi t∆∞·ª£ng JSON v√† in ch√∫ng ra
            Object.values(data).forEach(value => {
                appendMessage("ChatBot", BOT_IMG, "left", value);
                textToSpeech(value); // ƒê·ªçc to gi√° tr·ªã
            });
        })
        .catch(error => console.error('Error fetching bot responses:', error));
});


// Handle form submission
msgerForm.addEventListener("submit", event => {
    event.preventDefault();
    const msgText = msgerInput.value.trim().toLowerCase();
    if (!msgText) return;

    appendMessage("You", PERSON_IMG, "right", msgText);
    msgerInput.value = "";

    // First, fetch responses from the JSON file
    $.get('./responses.json')
        .done(function(data) {
            // Duy·ªát qua t·∫•t c·∫£ c√°c gi√° tr·ªã trong ƒë·ªëi t∆∞·ª£ng JSON v√† in ch√∫ng ra
            Object.values(data).forEach(value => {
                appendMessage("ChatBot", BOT_IMG, "left", value);
                textToSpeech(value); // ƒê·ªçc to gi√° tr·ªã
            });
        })
        .fail(function(error) {
            console.error('Error fetching bot responses:', error);
            appendMessage("ChatBot", BOT_IMG, "left", "An error occurred while fetching responses.");
        });

    // Then, call the botResponse function to get a response from the API
    botResponse(msgText);
});

// Bot Response function to call the Flask API
function botResponse(rawText) {
    // Use jQuery to send a GET request to the Flask API
    $.get("/get", { msg: rawText })
        .done(function(data) {
            console.log(rawText);
            console.log(data);
            
            const msgText = data; // Get the response from the API
            appendMessage("ChatBot", BOT_IMG, "left", msgText);
            textToSpeech(msgText); // Read out the response
        })
        .fail(function(error) {
            console.error('Error fetching response from API:', error);
            appendMessage("ChatBot", BOT_IMG, "left", "An error occurred while getting the response.");
        });
}




    
        // Ph·∫£n h·ªìi t·ª´ Bot sau khi ng∆∞·ªùi d√πng g·ª≠i tin nh·∫Øn
        function botResponse(userInput) {
            console.log('User input:', userInput);
            console.log('Bot responses:', botResponses);

            // Hi·ªÉn th·ªã tin nh·∫Øn "ChatBot ƒëang nghƒ©..."
            appendMessage("ChatBot", BOT_IMG, "left", "ChatBot ƒëang nghƒ©...");

            // T√¨m c√¢u tr·∫£ l·ªùi t·ª´ JSON
            const response = botResponses[userInput] || "Sorry, I don't understand your request.";

            // S·ª≠ d·ª•ng setTimeout ƒë·ªÉ t·∫°o ƒë·ªô tr·ªÖ tr∆∞·ªõc khi tr·∫£ v·ªÅ c√¢u tr·∫£ l·ªùi
            setTimeout(() => {
                // X√≥a tin nh·∫Øn "ChatBot ƒëang nghƒ©..."
                const lastMsg = msgerChat.lastElementChild;
                if (lastMsg && lastMsg.querySelector(".msg-info-name").textContent === "ChatBot" &&
                    lastMsg.querySelector(".msg-text").textContent === "ChatBot ƒëang nghƒ©...") {
                    lastMsg.remove();
                }

                // Hi·ªÉn th·ªã c√¢u tr·∫£ l·ªùi th·ª±c s·ª± c·ªßa bot
                appendMessage("ChatBot", BOT_IMG, "left", response);
                
                // Ph√°t √¢m thanh n·∫øu kh√¥ng ph·∫£i l√† c√¢u th√¥ng b√°o l·ªói
                if (response == "Sorry, I don't understand your request.") {
                    textToSpeech(response);
                }
            }, 2000); // Thay ƒë·ªïi 2000 th√†nh th·ªùi gian ch·ªù b·∫°n mu·ªën (t√≠nh b·∫±ng mili gi√¢y)
        }

    
        // Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i (Text-to-Speech)
        function textToSpeech(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            const synth = window.speechSynthesis;
    
            // Ki·ªÉm tra v√† thi·∫øt l·∫≠p gi·ªçng h·ª£p l·ªá
            utterance.voice = synth.getVoices().find(voice => voice.lang === 'en-US') || synth.getVoices()[0];
            // utterance.voice = synth.getVoices().find(voice => voice.lang === 'vi-VN') || synth.getVoices()[0];

    
            synth.speak(utterance);
    
            utterance.onstart = () => {
                console.log('Speech started');
            };
    
            utterance.onend = () => {
                console.log('Speech ended');
            };
        }
    
        // H√†m l∆∞u file v√†o th∆∞ m·ª•c c·ªë ƒë·ªãnh
        function saveFile(blob, fileName) {
            const fileReader = new FileReader();
            fileReader.onloadend = function() {
                const arrayBuffer = fileReader.result;
    
                // Gi·∫£ ƒë·ªãnh l∆∞u v√†o m·ªôt th∆∞ m·ª•c c·ªë ƒë·ªãnh tr√™n m√°y ch·ªß ho·∫∑c ƒë∆∞·ªùng d·∫´n x√°c ƒë·ªãnh
                const downloadDir = '../uploads'; // Th∆∞ m·ª•c c·ªë ƒë·ªãnh tr√™n m√°y ch·ªß
                const xhr = new XMLHttpRequest();
                xhr.open('POST', downloadDir, true);
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');
                xhr.setRequestHeader('File-Name', fileName);
                xhr.send(arrayBuffer);
            };
            fileReader.readAsArrayBuffer(blob);
        }
    
        // Th√™m tin nh·∫Øn v√†o giao di·ªán
        function appendMessage(name, img, side, text) {
            const msgHTML = `
            <div class="msg ${side}-msg">
                <div class="msg-img" style="background-image: url(${img})"></div>
                <div class="msg-bubble">
                    <div class="msg-info">
                        <div class="msg-info-name">${name}</div>
                        <div class="msg-info-time">${formatDate(new Date())}</div>
                    </div>
                    <div class="msg-text">${text}</div>
                </div>
            </div>
            `;
            msgerChat.insertAdjacentHTML("beforeend", msgHTML);
            msgerChat.scrollTop += 500;
        }
    
        // Timer cho qu√° tr√¨nh ghi √¢m
        function startTimer() {
            let seconds = 0;
            recordingTimer = get('.recording-timer');
            recordingTimer.innerHTML = "Recording: 00:00";
    
            timerInterval = setInterval(() => {
                seconds++;
                let min = Math.floor(seconds / 60);
                let sec = seconds % 60;
                recordingTimer.innerHTML = `Recording: ${formatTime(min)}:${formatTime(sec)}`;
            }, 1000);
        }
    
        function stopTimer() {
            clearInterval(timerInterval);
            recordingTimer.innerHTML = "Recording stopped.";
        }
    
        // ƒê·ªãnh d·∫°ng th·ªùi gian ƒë·ªÉ hi·ªÉn th·ªã mm:ss
        function formatTime(value) {
            return value < 10 ? `0${value}` : value;
        }
    
        // Utils
        function get(selector, root = document) {
            return root.querySelector(selector);
        }
    
        function formatDate(date) {
            const h = "0" + date.getHours();
            const m = "0" + date.getMinutes();
            return `${h.slice(-2)}:${m.slice(-2)}`;
        }
    
        const BOT_IMG = "https://image.flaticon.com/icons/svg/327/327779.svg";
        const PERSON_IMG = "https://image.flaticon.com/icons/svg/145/145867.svg";
        const express = require('express');

        // -------------------------------------------------------------server.js

        const fs = require('fs');
        const bodyParser = require('body-parser');
        const cors = require('cors');
        const path = require('path');
        const multer = require('multer');

        const app = express();
        const PORT = 3000;

        // Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c uploads n·∫øu kh√¥ng t·ªìn t·∫°i
        const uploadsDir = path.join(__dirname, 'uploads');
        if (!fs.existsSync(uploadsDir)) {
            fs.mkdirSync(uploadsDir);
        }

        // Setup multer for file uploads
        const storage = multer.diskStorage({
            destination: (req, file, cb) => {
                cb(null, uploadsDir); // L∆∞u file v√†o th∆∞ m·ª•c uploads
            },
            filename: (req, file, cb) => {
                cb(null, `${file.fieldname}_${Date.now()}.wav`); // T·∫°o t√™n file duy nh·∫•t
            }
        });
        const upload = multer({ storage: storage });

        // Middleware
        app.use(cors());
        app.use(bodyParser.json({ limit: '10mb' })); // TƒÉng gi·ªõi h·∫°n n·∫øu c·∫ßn
        app.use(express.static('./')); // Ph·ª•c v·ª• c√°c file tƒ©nh t·ª´ th∆∞ m·ª•c uploads

        // Route cho ƒë∆∞·ªùng d·∫´n g·ªëc
        app.get('/', (req, res) => {
            res.send('Welcome to the ChatBot API! Use /upload to upload audio and /downloads/:filename to download audio.');
        });

        // Endpoint ƒë·ªÉ upload audio (v·∫´n gi·ªØ l·∫°i n·∫øu c·∫ßn)
        app.post('/upload', upload.single('audio'), (req, res) => {
            console.log('Audio file uploaded successfully:', req.file);
            res.json({ message: 'Audio file saved successfully!', file: req.file.path });
        });

        // Endpoint ƒë·ªÉ t·∫£i file √¢m thanh
        app.get('/downloads/:filename', (req, res) => {
            const filePath = path.join(uploadsDir, req.params.filename);
            res.download(filePath, (err) => {
                if (err) {
                    console.error("File download error:", err);
                    res.status(500).send("Error downloading file.");
                } else {
                    console.log(`File downloaded: ${filePath}`);
                }
            });
        });

        // Start the server
        app.listen(PORT, () => {
            console.log(`Server is running on http://localhost:${PORT}`);
        });

    </script>
    
    </script>

</body>
asdfasdf
</html>
asdfasddfasddfasfasdf